#!/usr/bin/python

# For Google Code Hosting.
import gdata.projecthosting.client
import gdata.projecthosting.data
import gdata.gauth
import gdata.client
import gdata.data
import atom.http_core
import atom.core

# For everything else.
import sys
import re
import getopt
import string
import datetime
import xml.sax
import xml.sax.handler

def usage(output_stream=sys.stdout):
  output_stream.write("TBD\n")

#########################################################################
###
### This bit of code is from Wai Yip Tung, see the original at:
###
### http://code.activestate.com/recipes/534109-xml-to-python-data-structure/
###
### He clearly intended it to be open source, even though he didn't
### put an explicit license on it.  His documentation and comments
### make that clear:
###
###   To access its data, you can do the following:
###   
###   person.gender        -> 'm'     # an attribute
###   person['gender']     -> 'm'     # alternative dictionary syntax
###   person.name          -> 'fred'  # shortcut to a text node
###   person.phone[0].type -> 'home'  # multiple elements becomes an list
###   person.phone[0].data -> '54321' # use .data to get the text value
###   str(person.phone[0]) -> '54321' # alternative syntax for the text value
###   person[0]            -> person  # if only one <person>, it can still
###                                   # be used as if it's a list of 1 elt.
###   'address' in person  -> False   # test for existence of an attr or child
###   person.address       -> None    # non-exist element returns None
###   bool(person.address) -> False   # has any 'address' data
###                                   # (attr, child or text)
###   person.note          -> '"A <note>"'
###   
###   This function is inspired by David Mertz' Gnosis objectify
###   utilities. The motivation of writing this recipe is for
###   simplicity. With just 100 lines of code packaged into a single
###   function, it can easily be embedded with other code for ease of
###   distribution.
###
#########################################################################

def xml2obj(src):
    """A simple function to convert XML data into a native Python object."""

    non_id_char = re.compile('[^_0-9a-zA-Z]')
    def _name_mangle(name):
        return non_id_char.sub('_', name)

    class DataNode(object):
        def __init__(self):
            self._attrs = {}    # XML attributes and child elements
            self.data = None    # child text data
        def __len__(self):
            # treat single element as a list of 1
            return 1
        def __getitem__(self, key):
            if isinstance(key, basestring):
                return self._attrs.get(key,None)
            else:
                return [self][key]
        def __contains__(self, name):
            return self._attrs.has_key(name)
        def __nonzero__(self):
            return bool(self._attrs or self.data)
        def __getattr__(self, name):
            if name.startswith('__'):
                # need to do this for Python special methods???
                raise AttributeError(name)
            return self._attrs.get(name,None)
        def _add_xml_attr(self, name, value):
            if name in self._attrs:
                # multiple attribute of the same name are represented by a list
                children = self._attrs[name]
                if not isinstance(children, list):
                    children = [children]
                    self._attrs[name] = children
                children.append(value)
            else:
                self._attrs[name] = value
        def __str__(self):
            return self.data or ''
        def __repr__(self):
            items = sorted(self._attrs.items())
            if self.data:
                items.append(('data', self.data))
            return u'{%s}' % ', '.join([u'%s:%s' % (k,repr(v)) for k,v in items])

    class TreeBuilder(xml.sax.handler.ContentHandler):
        def __init__(self):
            self.stack = []
            self.root = DataNode()
            self.current = self.root
            self.text_parts = []
        def startElement(self, name, attrs):
            self.stack.append((self.current, self.text_parts))
            self.current = DataNode()
            self.text_parts = []
            # xml attributes --> python attributes
            for k, v in attrs.items():
                self.current._add_xml_attr(_name_mangle(k), v)
        def endElement(self, name):
            text = ''.join(self.text_parts).strip()
            if text:
                self.current.data = text
            if self.current._attrs:
                obj = self.current
            else:
                # a text only node is simply represented by the string
                obj = text or ''
            self.current, self.text_parts = self.stack.pop()
            self.current._add_xml_attr(_name_mangle(name), obj)
        def characters(self, content):
            self.text_parts.append(content)

    builder = TreeBuilder()
    if isinstance(src,basestring):
        xml.sax.parseString(src, builder)
    else:
        xml.sax.parse(src, builder)
    return builder.root._attrs.values()[0]

#########################################################################
###
### End section of code by Wai Yip Tung.
###
#########################################################################


#########################################################################
# See http://bugs.python.org/issue6641 about how the "%z" timezone
# offset handling is broken, which is we we write the logic by hand
# below.  See also http://stackoverflow.com/questions/3286817/\
# convert-string-timestamp-with-timezone-offset-to-local-time-python
# for more discussion.
def date_from_string(s):
  """Convert string S into a datetime.datetime.  S looks like
  "Fri, 16 Jul 2010 07:08:23 -0700", "Wed, 8 Dec 2010 17:28:55 -0800",
  etc, except that the timezone offset is optional."""
  tzoffset, hours, mins = None, 0, 0
  if s[-5] == '-' and re.match("[0-9][0-9][0-9][0-9]", s[-4:]):
    s, tzoffset = s[:-6], s[-5:]
    sign, hours, mins = tzoffset[0], int(tzoffset[1:3]), int(tzoffset[3:])
    if sign == '-':
      hours, mins = hours * -1, mins * -1
  d = datetime.datetime.strptime(s, '%a, %d %b %Y %H:%M:%S')
  return d + datetime.timedelta(hours = hours, minutes = mins)


# An issue coming from JIRA looks like this:
#
# <item>
#  <title>[MAD-174] summary of issue</title>
#  <link>URL to issue (e.g., http://sfgovdt.jira.com/browse/MAD-174</link>
#  <project id="10020" key="MAD">Enterprise Addressing System</project>
#  <description>&lt;p&gt;Should probably consistently upper case things on the server where it matters (as with streets).&lt;/p&gt;</description>
#  <environment/>
#  <key id="10273">MAD-174</key>
#  <summary>same as summary part of summary -- use this</summary>
#  <type id="1" iconUrl="http://sfgovdt.jira.com/images/icons/bug.gif">Bug</type>
#  <priority id="3"
#            iconUrl="http://sfgovdt.jira.com/images/icons/priority_major.gif"
#    >Major</priority>
#  <status id="1"
#          iconUrl="http://sfgovdt.jira.com/images/icons/status_open.gif"
#    >Open</status>
#  <resolution id="-1">Unresolved</resolution>
#  <assignee username="pmccullough">Paul McCullough</assignee>
#  <reporter username="pmccullough">Paul McCullough</reporter>
#  <created>Wed, 8 Dec 2010 17:28:55 -0800</created>
#  <updated>Wed, 8 Dec 2010 17:28:55 -0800</updated>
#  <version>1.0 beta</version>
#  <fixVersion>1.0</fixVersion>
#  <due/>
#  <votes>0</votes>
#  <comments>
#   <comment id="10378"
#            author="pmccullough"
#            created="Fri, 3 Dec 2010 15:39:04 -0800"
#     >&lt;p&gt;Attached is a histogram of unit nums in EAS.&lt;/p&gt;
#     &lt;div class="code panel" style="border-width: 1px;"&gt;&lt;div class="codeContent panelContent"&gt;
#lt;pre class="code-java"&gt;select count(*), unit_num
#rom addresses
#roup by unit_num
#rder by unit_num&lt;/pre&gt;
#lt;/div&gt;&lt;/div&gt;</comment>
# </comments>
# <attachments>
#  <attachment id="10023"
#    name="distinct_unit_num.csv"
#    size="75809"
#    author="pmccullough"
#    created="Fri, 3 Dec 2010 15:39:04 -0800"/>
#  </attachments>
#  <subtasks></subtasks>
#  <customfields>
#   <customfield id="customfield_10011"
#                key="com.atlassian.jira.plugin.labels:labels">
#    <customfieldname>Epic/Theme</customfieldname>
#    <customfieldvalues>
#      <customfieldvalue><![CDATA[]]></customfieldvalue>
#    </customfieldvalues>
#   </customfield>
#  </customfields>
# </item>


class IssueComment():
  """A comment on an Issue.
  TODO: The current representation is probably biased in favor of JIRA
  issue comments, since that is the initial implementation.  Please
  further generalize this class as more issue types are added."""
  def __init__(self, author_username=None, summary=None, body=None,
               date_created=None, source_id=None):
    """
    AUTHOR_USERNAME is a string or None.
    SUMMARY is a string or None.
    BODY is a string or None.
    DATE_CREATED is a datetime or None.
    SOURCE_ID is a string or None.
    """
    self.author_username = author_username
    self.summary = summary
    self.body = body
    self.date_created = date_created
    self.source_id = source_id

  def __str__(self):
    return """Comment by %s (%s, id=%s):
  %s
  %s

  """ % (self.author_username, self.date_created,
         self.source_id, self.summary, self.body)


class IssueAttachment():
  """An attachment on an Issue (or, in the future, on an IssueComment).
  TODO: Some systems attach attachments to comments, others to the
  bug itself, and maybe some allow it to both.  Right now, what we
  support is attachments on the bug itself, because that's what
  JIRA seems to do."""
  def __init__(self, source_id=None, filename=None, size=None,
               username=None, date_created=None):
    """TODO: document."""
    self.source_id = source_id
    self.filename = filename
    self.size = size
    self.username = username
    self.date_created = date_created

  def __str__(self):
    return """Attachment '%s' uploaded by %s
  (%d bytes on %s; original id %s)

  """ % (self.filename, self.username,
         self.size, self.date_created, self.source_id)


class Issue():
  def __init__(self,
               summary,                # string: One-liner summary.
               description,            # string: Initial description.
               source_link,            # string: URL to original bug.
               source_id,              # string: Unique id of original bug.
               issue_type,             # string: defect / task / enhancement
               priority,               # string: 
               status,                 # string:
               resolution,             # string:
               reporter,               # (string, string): realname, username
               assignee,               # (string, string): realname, username
               date_created,           # datetime:
               date_last_updated,      # datetime:
               version_filed_against,  # string:
               version_fixed_for,      # string:
               ):
    self.summary               = summary
    self.description           = description
    self.source_link           = source_link
    self.source_id             = source_id
    self.issue_type            = issue_type
    self.priority              = priority
    self.status                = status
    self.resolution            = resolution
    self.reporter              = reporter
    self.assignee              = assignee
    self.date_created          = date_created
    self.date_last_updated     = date_last_updated
    self.version_filed_against = version_filed_against
    self.version_fixed_for     = version_fixed_for
    self.labels                = []  # strings
    self.comments              = []  # See IssueComment
    self.attachments           = []  # See IssueAttachment

  def add_comment(self, source_id, author_username, date_created,
                  summary, body):
    """Add a comment.  TODO: document, yo."""
    c = IssueComment(author_username, summary, body, date_created, source_id)
    self.comments.append(c)

  def add_attachment(self, source_id, filename, size, username, date_created):
    """Add an attachment.  TODO: document, yo."""
    a = IssueAttachment(source_id, filename, size, username, date_created)
    self.attachments.append(a)

  def add_label(self, label):
    """Add LABEL to this issue iff it's not already on this issue."""
    if label not in self.labels:
      self.labels.append(label)

  def __str__(self):
    s = """Issue %s: %s
  %s
  
  Source URL:      %s
  Reporter:        %s (%s)
  Assignee:        %s (%s)
  Type:            %s
  Priority:        %s
  Status:          %s
  Resolution:      %s
  Filed against:   %s
  Fixed in:        %s
  Created:         %s
  Last updated:    %s
  Labels:          %s

  """ % (self.source_id,
         self.summary,
         self.description,
         self.source_link,
         self.reporter[0], self.reporter[1],
         self.assignee[0], self.assignee[1],
         self.issue_type,
         self.priority,
         self.status,
         self.resolution,
         self.version_filed_against,
         self.version_fixed_for,
         self.date_created,
         self.date_last_updated,
         ", ".join(self.labels),
         )
    for c in self.comments:
      s = s + str(c)
    for a in self.attachments:
      s = s + str(a)
    return s


def issue_from_jira(jira_xml_obj):
  """Return a generic Issue object based on JIRA_XML_OBJ."""
  def safe(stringthing):
    if isinstance(stringthing, basestring): # TODO: Or ask if unicode?
      return stringthing.encode('ascii', 'xmlcharrefreplace')
    return stringthing
  issue = Issue(safe(jira_xml_obj.summary),
                safe(jira_xml_obj.description),
                safe(jira_xml_obj.link),
                safe(jira_xml_obj.key),
                safe(jira_xml_obj.type),
                safe(jira_xml_obj.priority),
                safe(jira_xml_obj.status),
                safe(jira_xml_obj.resolution),
                (safe(jira_xml_obj.reporter.data),
                 safe(jira_xml_obj.reporter.username)),
                (safe(jira_xml_obj.assignee.data),
                 safe(jira_xml_obj.assignee.username)),
                date_from_string(safe(jira_xml_obj.created)),
                date_from_string(safe(jira_xml_obj.updated)),
                safe(jira_xml_obj.version),
                safe(jira_xml_obj.fixVersion))

  if jira_xml_obj.customfields:
    for f in jira_xml_obj.customfields.customfield:
      if f.key[-7:] == ":labels":
        # Ignore the 'customfieldvalue', only the name matters.
        issue.add_label(f.customfieldname)

  if jira_xml_obj.comments:
    for c in jira_xml_obj.comments.comment:
      issue.add_comment(c.id, safe(c.author),
                        date_from_string(c.created),
                        None, safe(c.data))

  if jira_xml_obj.attachments:
    for a in jira_xml_obj.attachments.attachment:
      issue.add_attachment(a.id, safe(a.name), int(a.size),
                           safe(a.author), date_from_string(a.created))

  return issue


class UserMap():
  """TODO: doc"""
  def __init__(self, userdict):
    self.userdict = userdict
  def get_user(self, orig_user):
    new_user = self.userdict.get(orig_user, None)
    if new_user is None or new_user == '':
      new_user = self.userdict.get('')
    return new_user


class Project():
  """A GCH Project, reachable through a client."""
  def __init__(self, name, client, usermap):
    self.name = name
    self.client = client
    self.usermap = usermap
    
  def show_all_issues(self):
    """Show all the issues in a project."""
    feed = self.client.get_issues(self.name)
    for issue in feed.entry:
      print issue.title.text

  def import_issue(self, issue):
    """Import ISSUE into this Google Code Hosting project."""
    print "### Creating an issue:"
    owner = self.usermap.get_user(issue.assignee[1])
    # See http://code.google.com/p/support/issues/detail?id=4778
    # for why we trap a particular issue here for now.
    if issue.source_id.data == "MAD-119":
      print "  # Creating issue %s" % issue.source_id
      sys.stdout.flush()
      gch_issue = self.client.add_issue(
        self.name, # project name, not issue name
        issue.summary, # our "summary" is Google's "title"
        issue.description, # our "description" is Google's "summary"
        owner, labels=issue.labels)
      for c in issue.comments:
        continue # TODO: fooo working here
        comment_owner = self.usermap.get_user(c.author_username)
        self.client.update_issue(
          self.name,
          gch_issue.id,
          comment_owner,
          comment=c.body,
          summary=c.summary,
          status='Accepted',
          owner=comment_owner,
          )
      print "  # Done"
    else:
      print "  # Faking it for issue %s" % issue.source_id


def authenticate_client(client, project, username, password):
  """Authenticate CLIENT to PROJECT, with USERNAME and PASSWORD."""
  client.client_login(username, password, source=project, service='code')


def create_usermap(mapfile):
  f = file(mapfile)
  line = f.readline().strip()
  umap = {}
  while line != '':
    first_colon = line.find(':')
    orig, new = line[:first_colon].lstrip(), line[first_colon + 1:].lstrip()
    umap[orig] = new
    line = f.readline().strip()
  return UserMap(umap)


def main():
  error_exit   = False
  project_name = None
  username     = None
  password     = None
  issues_xml   = None
  # Dictionary mapping old usernames to new identities.  Entry whose
  # key is empty string is the default, by convention.  Yes, that's
  # kind of klugey.  Patches welcome.
  usermap      = None

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               '',
                               [ "project=",
                                 "username=",
                                 "password=",
                                 "usermap=",
                                 "issues-xml=",   # XML data source file
                                 "issues-type=",  # e.g., "jira", etc.
                               ])
  except getopt.GetoptError:
    sys.stderr.write("Error: problem processing options\n")
    usage(sys.stderr)
    sys.exit(1)

  for opt, val in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    elif opt == '--project':
      project_name = val
    elif opt == '--username':
      username = val
    elif opt == '--password':
      # TODO: this should be read in at a non-echo prompt, to avoid a
      # process listing revealing the password.
      password = val
    elif opt == '--usermap':
      usermap = create_usermap(val)
    elif opt == '--issues-xml':
      issues_xml = file(val)
    elif opt == '--issues-type':
      issues_type = val
    else:
      sys.stderr.write("Error: unrecognized option: '%s'\n" % opt)
      error_exit = True

  if issues_type is None or issues_type.lower() not in ("jira"):
    sys.stderr.write("Error: unrecognized issues type: '%s'\n" % issues_type)
    error_exit = True

  if error_exit:
    usage(sys.stderr)
    sys.exit(1)

  client = gdata.projecthosting.client.ProjectHostingClient()
  authenticate_client(client, project_name, username, password)
  gch_proj = Project(project_name, client, usermap)
  print "### Showing all issues:"
  gch_proj.show_all_issues()
  print ""

  # Try parsing some JIRA XML.
  issues = xml2obj(issues_xml)
  # Cdr down the stack until we are the object of our desires.
  if issues.channel:
    issues = issues.channel.item
  for jira_issue in issues:
    issue = issue_from_jira(jira_issue)
    gch_proj.import_issue(issue)

  print ""
  print "### Showing all issues again:"
  print ""
  gch_proj.show_all_issues()
  print ""
  print "### Remember to delete any test issues via the UI."
  print ""

  issues_xml.close()

if __name__ == '__main__':
  main()
